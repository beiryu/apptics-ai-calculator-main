// @ts-nocheck
/* eslint-disable */
/* This file was generated by Unframer for Framer project 82805ebdf0b5ff0d "Apptics (copy)", do not edit manually */
"use client";

/**
 * @typedef Locale
 * string
 */

/**
 * @typedef {{
 * children?: React.ReactNode
 * locale?: Locale
 * style?: React.CSSProperties
 * className?: string
 * id?: string
 * ref?: any
 * width?: any
 * height?: any
 * layoutId?: string
 * source?: 'URL' | 'Upload' // Source
 * uRL?: string // URL
 * file?: string // File
 * playing?: boolean // Playing
 * canvas?: 'Pause' | 'Play' // Canvas
 * loop?: boolean // Loop
 * direction?: 'Normal' | 'Reverse' // Direction
 * speed?: number // Speed
 * poster?: 'Auto' | 'Custom' // Poster
 * poster?: string // Poster
 * progress?: number // Progress
 * fillType?: 'Contain' | 'Cover' | 'Fill' | 'None' | 'Scale Down' | 'Stretch' // Fill Type
}} Props

 */
import { routes } from "./chunks/chunk-VAWW4KIH.js";

// virtual:lottie-player
import { Fragment } from "react";
import { ContextProviders } from "unframer";

// /:https://framerusercontent.com/modules/kWjG6pBLXtcxjCWZuv6I/pZZj7FIkF00uo3kxZih0/LottiePlayer.js
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useEffect, useRef, useState, startTransition, useCallback, useMemo } from "react";
import { addPropertyControls, ControlType, RenderTarget } from "unframer";
var lottieCache = /* @__PURE__ */ new Map();
var lottieScriptLoaded = false;
var lottieScriptPromise = null;
if (typeof window !== "undefined" && !lottieScriptLoaded && !lottieScriptPromise) {
  lottieScriptPromise = new Promise((resolve, reject) => {
    if (window.lottie) {
      lottieScriptLoaded = true;
      window.LottiePlayerLottie = window.lottie;
      resolve(window.LottiePlayerLottie);
      return;
    }
    const script = document.createElement("script");
    script.src = "https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js";
    script.async = true;
    script.onload = () => {
      lottieScriptLoaded = true;
      window.LottiePlayerLottie = window.lottie;
      resolve(window.LottiePlayerLottie);
    };
    script.onerror = () => {
      lottieScriptPromise = null;
      reject(new Error("Failed to load Lottie script"));
    };
    document.head.appendChild(script);
  });
}
function LottiePlayer(props) {
  const {
    sourceType,
    lottieUrl,
    lottieFile = "https://assets10.lottiefiles.com/packages/lf20_5ngs2ksb.json",
    playing,
    loop,
    direction,
    speed,
    posterType,
    posterFile = "https://framerusercontent.com/images/GfGkADagM4KEibNcIiRUWlfrR0.jpg",
    progress,
    fillType,
    style,
    canvasPlaying,
  } = props;
  const containerRef = useRef(null);
  const lottieInstance = useRef(null);
  const loadTimeoutRef = useRef(null);
  const [lottieLoaded, setLottieLoaded] = useState(false);
  const [lottieData, setLottieData] = useState(null);
  const [lottieError, setLottieError] = useState("");
  const [isIntersecting, setIsIntersecting] = useState(true);
  const [scriptReady, setScriptReady] = useState(false);
  const currentSource = useMemo(() => {
    return sourceType === "url" ? lottieUrl : lottieFile;
  }, [sourceType, lottieUrl, lottieFile]);
  const loadLottieScript = useCallback(() => {
    if (typeof window === "undefined") return Promise.reject("No window");
    if (lottieScriptLoaded && window.LottiePlayerLottie) {
      return Promise.resolve(window.LottiePlayerLottie);
    }
    if (lottieScriptPromise) return lottieScriptPromise;
    return Promise.reject("Script loading failed");
  }, []);
  useEffect(() => {
    if (typeof window === "undefined") return;
    const checkScript = () => {
      if (window.lottie || window.LottiePlayerLottie) {
        lottieScriptLoaded = true;
        window.LottiePlayerLottie = window.lottie || window.LottiePlayerLottie;
        startTransition(() => setScriptReady(true));
        return;
      }
      if (lottieScriptPromise) {
        lottieScriptPromise
          .then(() => startTransition(() => setScriptReady(true)))
          .catch(() => {
            const script = document.createElement("script");
            script.src = "https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js";
            script.async = true;
            script.onload = () => {
              lottieScriptLoaded = true;
              window.LottiePlayerLottie = window.lottie;
              startTransition(() => setScriptReady(true));
            };
            document.head.appendChild(script);
          });
      }
    };
    checkScript();
    const timeoutId = setTimeout(checkScript, 100);
    return () => clearTimeout(timeoutId);
  }, []);
  const loadLottieData = useCallback(async (url) => {
    if (!url) return null;
    if (lottieCache.has(url)) {
      return lottieCache.get(url);
    }
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 1e4);
      const response = await fetch(url, {
        signal: controller.signal,
        cache: "force-cache",
        // Use browser cache when possible
      });
      clearTimeout(timeoutId);
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      const data = await response.json();
      lottieCache.set(url, data);
      return data;
    } catch (error) {
      console.warn("Lottie load failed:", error.message);
      throw error;
    }
  }, []);
  useEffect(() => {
    if (typeof window === "undefined") return;
    const observer = new IntersectionObserver(
      ([entry]) => {
        startTransition(() => setIsIntersecting(entry.isIntersecting));
      },
      {
        threshold: 0.01,
        rootMargin: "100px",
      }
    );
    if (containerRef.current) {
      observer.observe(containerRef.current);
    }
    return () => observer.disconnect();
  }, []);
  useEffect(() => {
    if (!scriptReady || !currentSource) return;
    if (loadTimeoutRef.current) {
      clearTimeout(loadTimeoutRef.current);
    }
    setLottieError("");
    setLottieLoaded(false);
    const loadAnimation = async () => {
      try {
        const [lottieLib, data] = await Promise.all([
          loadLottieScript(),
          loadLottieData(currentSource),
        ]);
        if (data && lottieLib) {
          startTransition(() => {
            setLottieData(data);
            setLottieLoaded(true);
          });
        }
      } catch (error) {
        console.warn("Lottie loading failed:", error);
        startTransition(() => {
          setLottieError("Failed to load animation");
        });
      }
    };
    loadAnimation();
    return () => {
      if (loadTimeoutRef.current) {
        clearTimeout(loadTimeoutRef.current);
      }
    };
  }, [currentSource, scriptReady, loadLottieScript, loadLottieData]);
  const preserveAspectRatio = useMemo(() => {
    switch (fillType) {
      case "contain":
        return "xMidYMid meet";
      case "cover":
        return "xMidYMid slice";
      case "fill":
      case "stretch":
      case "none":
        return "none";
      case "scale-down":
        return "xMidYMid meet";
      default:
        return "xMidYMid meet";
    }
  }, [fillType]);
  useEffect(() => {
    if (!lottieLoaded || !lottieData || !containerRef.current || !scriptReady) return;
    if (typeof window === "undefined" || !window.LottiePlayerLottie) return;
    if (lottieInstance.current) {
      try {
        lottieInstance.current.destroy();
      } catch (e) {
        console.warn("Error destroying previous instance:", e);
      }
      lottieInstance.current = null;
    }
    if (containerRef.current) {
      containerRef.current.innerHTML = "";
    }
    try {
      const lottieConfig = {
        container: containerRef.current,
        renderer: "svg",
        loop,
        autoplay: false,
        animationData: lottieData,
        rendererSettings: {
          preserveAspectRatio,
          imagePreserveAspectRatio: preserveAspectRatio,
          progressiveLoad: true,
          clearCanvas: false,
          filterSize: {
            width: "300%",
            height: "300%",
            x: "-100%",
            y: "-100%",
          },
          viewBoxOnly: false,
          hideOverflow: false,
          svgContainerStyle: "overflow: visible !important;",
          className: "lottie-svg-container",
        },
      };
      lottieInstance.current = window.LottiePlayerLottie.loadAnimation(lottieConfig);
      lottieInstance.current.addEventListener("DOMLoaded", () => {
        if (!lottieInstance.current) return;
        try {
          lottieInstance.current.setSpeed(speed);
          lottieInstance.current.setDirection(direction === "normal" ? 1 : -1);
          lottieInstance.current.goToAndStop(progress * lottieInstance.current.totalFrames, true);
          if (playing) {
            lottieInstance.current.play();
          }
        } catch (error) {
          console.warn("Error configuring animation:", error);
        }
      });
      lottieInstance.current.addEventListener("error", (error) => {
        console.warn("Lottie animation error:", error);
        startTransition(() => {
          setLottieError("Animation playback error");
        });
      });
    } catch (error) {
      console.warn("Lottie initialization failed:", error);
      startTransition(() => {
        setLottieError("Animation failed to initialize");
      });
    }
    return () => {
      if (lottieInstance.current) {
        try {
          lottieInstance.current.destroy();
        } catch (e) {
          console.warn("Error destroying instance:", e);
        }
        lottieInstance.current = null;
      }
    };
  }, [lottieLoaded, lottieData, loop, direction, speed, preserveAspectRatio, scriptReady]);
  useEffect(() => {
    if (!lottieInstance.current) return;
    try {
      if (playing) {
        lottieInstance.current.play();
      } else {
        lottieInstance.current.pause();
      }
    } catch (error) {
      console.warn("Lottie play/pause failed:", error);
    }
  }, [playing]);
  useEffect(() => {
    if (RenderTarget.current() !== RenderTarget.canvas) return;
    if (!lottieInstance.current) return;
    try {
      if (canvasPlaying) {
        lottieInstance.current.play();
      } else {
        lottieInstance.current.pause();
      }
    } catch (error) {
      console.warn("Canvas play/pause failed:", error);
    }
  }, [canvasPlaying]);
  useEffect(() => {
    if (!lottieInstance.current) return;
    try {
      const frame = Math.max(
        0,
        Math.min(
          progress * lottieInstance.current.totalFrames,
          lottieInstance.current.totalFrames - 1
        )
      );
      lottieInstance.current.goToAndStop(frame, true);
    } catch (error) {
      console.warn("Lottie progress update failed:", error);
    }
  }, [progress]);
  return (
    <div
      style={{
        ...style,
        width: "100%",
        height: "100%",
        position: "relative",
        background: "transparent",
        overflow: "visible",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
      }}
    >
      <div
        ref={containerRef}
        style={{
          width: "100%",
          height: "100%",
          objectFit: fillType,
          objectPosition: "center",
          display: "block",
          overflow: "visible",
        }}
        aria-label={"Lottie Animation"}
      />
      {lottieError && (
        <div
          style={{
            position: "absolute",
            top: 0,
            left: 0,
            width: "100%",
            height: "100%",
            background: "rgba(255, 255, 255, 0.9)",
            color: "#d00",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            fontSize: 14,
            zIndex: 2,
            backdropFilter: "blur(2px)",
          }}
        >
          {lottieError}
        </div>
      )}
    </div>
  );
}
addPropertyControls(LottiePlayer, {
  sourceType: {
    type: ControlType.Enum,
    title: "Source",
    options: ["url", "upload"],
    optionTitles: ["URL", "Upload"],
    defaultValue: "upload",
    displaySegmentedControl: true,
  },
  lottieUrl: {
    type: ControlType.String,
    title: "URL",
    placeholder: "https://.../animation.json",
    defaultValue: "https://assets10.lottiefiles.com/packages/lf20_5ngs2ksb.json",
    hidden: ({ sourceType }) => sourceType !== "url",
  },
  lottieFile: {
    type: ControlType.File,
    allowedFileTypes: ["json"],
    title: "File",
    hidden: ({ sourceType }) => sourceType !== "upload",
  },
  playing: {
    type: ControlType.Boolean,
    title: "Playing",
    defaultValue: true,
    enabledTitle: "Yes",
    disabledTitle: "No",
  },
  canvasPlaying: {
    type: ControlType.Enum,
    title: "Canvas",
    options: [false, true],
    optionTitles: ["Pause", "Play"],
    defaultValue: false,
    displaySegmentedControl: true,
  },
  loop: {
    type: ControlType.Boolean,
    title: "Loop",
    defaultValue: true,
    enabledTitle: "Yes",
    disabledTitle: "No",
  },
  direction: {
    type: ControlType.Enum,
    title: "Direction",
    options: ["normal", "reverse"],
    optionTitles: ["Normal", "Reverse"],
    defaultValue: "normal",
    displaySegmentedControl: true,
  },
  speed: {
    type: ControlType.Number,
    title: "Speed",
    defaultValue: 1,
    min: 0.1,
    max: 3,
    step: 0.1,
    unit: "x",
    displayStepper: true,
  },
  posterType: {
    type: ControlType.Enum,
    title: "Poster",
    options: ["auto", "custom"],
    optionTitles: ["Auto", "Custom"],
    defaultValue: "auto",
    displaySegmentedControl: true,
    hidden: () => true,
  },
  posterFile: {
    type: ControlType.File,
    allowedFileTypes: ["jpg", "jpeg", "png", "webp", "gif"],
    title: "Poster",
    hidden: () => true,
  },
  progress: {
    type: ControlType.Number,
    title: "Progress",
    defaultValue: 0,
    min: 0,
    max: 1,
    step: 0.01,
    unit: "",
  },
  fillType: {
    type: ControlType.Enum,
    title: "Fill Type",
    options: ["contain", "cover", "fill", "none", "scale-down", "stretch"],
    optionTitles: ["Contain", "Cover", "Fill", "None", "Scale Down", "Stretch"],
    defaultValue: "contain",
    displaySegmentedControl: false,
  },
});

// virtual:lottie-player
import { WithFramerBreakpoints } from "unframer";
import { jsx } from "react/jsx-runtime";
var locales = [];
var defaultResponsiveVariants = {};
/** @type {function(Props): any} */
function ComponentWithRoot({ locale, ...rest }) {
  return (
    <ContextProviders
      routes={routes}
      framerSiteId={"82805ebdf0b5ff0d009fec4f748e6f81207f7e9b7f138594ce37e1d247ff0150"}
      locale={locale}
      locales={locales}
    >
      <LottiePlayer {...rest} />
    </ContextProviders>
  );
}
/**
 * @type {import("unframer").UnframerBreakpoint}
 * Represents a responsive breakpoint for unframer.
 */

/**
 * @typedef VariantsMap
 * Partial record of UnframerBreakpoint to Props.variant, with a mandatory 'base' key.
 * { [key in UnframerBreakpoint]?: Props['variant'] } & { base: Props['variant'] }
 */

/**
 * Renders LottiePlayerFramerComponent for all breakpoints with a variants map. Variant prop is inferred per breakpoint.
 * @function
 * @param {Omit<Props, 'variant'> & {variants?: VariantsMap}} props
 * @returns {any}
 */
ComponentWithRoot.Responsive = ({ locale = "", ...rest }) => {
  return (
    <ContextProviders
      routes={routes}
      framerSiteId={"82805ebdf0b5ff0d009fec4f748e6f81207f7e9b7f138594ce37e1d247ff0150"}
      locale={locale}
      locales={locales}
    >
      <WithFramerBreakpoints
        Component={LottiePlayer}
        variants={defaultResponsiveVariants}
        {...rest}
      />
    </ContextProviders>
  );
};
Object.assign(ComponentWithRoot, LottiePlayer);
var lottie_player_default = ComponentWithRoot;
export { lottie_player_default as default };
